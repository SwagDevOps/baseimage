#!/usr/bin/env ruby
# coding: utf-8
# frozen_string_literal: true
# rubocop:disable Style/AsciiComments

# Setup ``dropbear`` server
#
# Sample config directory structure:
#
# ```
# /etc/dropbear/
# ├── allow
# │   └── root
# ├── host_rsa
# └── host_rsa.pem
# ```
#
# ``host_rsa`` file SHOULD be mounted, or it will be generated
# it can be converted from a PEM file (``host_rsa.pem``).
# Files found in ``/etc/dropbear/allow`` will be copied,
# to the corresponding users ``.ssh`` directories.
#
# ```sh
# yes | ssh-keygen \
#      -t rsa -b 4096 -N '' \
#     -f host_rsa.pem -m PEM -C "your_email@example.com"
# ```
class DropbearSetup
  autoload :Etc, 'etc'
  autoload :Pathname, 'pathname'
  autoload :Shellwords, 'shellwords'
  autoload :FileUtils, 'fileutils'

  # Get directory
  #
  # @return [Pathname]
  attr_reader :directory

  # Dropbear private key
  #
  # @return [Pathname]
  attr_reader :host_key

  # PEM RSA private key
  #
  # @return [Pathname]
  attr_reader :host_pem

  def initialize(directory = ENV['DROPBEAR_CONFDIR'])
    @directory = Pathname.new(directory || '/etc/dropbear')

    @host_key = Pathname.new('host_rsa')
    @host_pem = Pathname.new("#{@host_key}.pem")
  end

  # @return [String]
  def to_path
    directory.to_path
  end

  # @return [self]
  def call
    self.to_path.tap do |directory|
      utils.mkdir_p(directory)
      Dir.chdir(directory) do
        convert_pem
        gen_key

        apply_perms
        authorize
      end
    end

    self
  end

  protected

  # Convert pem file.
  #
  # @return [self]
  def convert_pem
    cmd = ['dropbearconvert', 'openssh', 'dropbear', host_pem, host_key]

    if host_pem.file? and host_pem.readable?
      utils.chmod(0o600, host_pem)
      sh(*cmd.map(&:to_s))
    end

    self
  end

  # Create private key used with dropbear.
  #
  # #param [String|Symbol] type
  # @return [self]
  #
  # @see http://manpages.ubuntu.com/manpages/precise/man8/dropbearkey.8.html
  # @see https://www.mail-archive.com/dropbear@ucc.asn.au/msg01689.html
  def gen_key(type = :rsa)
    cmd = ['dropbearkey', '-f', host_key]
    cmd = (host_key.file? ? cmd.push('-y') : cmd.push('-t', type)).map(&:to_s)

    sh(*cmd)
    utils.chmod(0o600, host_key)

    self
  end

  # @return self
  def apply_perms
    utils.chmod(0o700, 'allow')
    Dir.glob('allow/*').each { |file| utils.chmod(0o600, file) }
  rescue StandardError # rubocop:disable Lint/HandleExceptions
  ensure
    self
  end

  # Dispatch authorized_keys files.
  #
  # @return [self]
  def authorize
    authorizables.each do |file, user|
      begin
        Pathname.new("#{user.dir}/.ssh/authorized_keys")
                .tap { |target| copy_auth(file, target, user) }
      rescue StandardError => e
        warn(e.message)
      end
    end

    self
  end

  # @return [Hash{String => Etc::Passwd}]
  def authorizables
    Dir.glob('allow/*').map do |file|
      begin
        user = Etc.getpwnam(Pathname.new(file).basename.to_s)
        [file, user]
      rescue ArgumentError => e
        warn(e.message)
      end
    end.compact.to_h
  end

  private

  # @return [FileUtils]
  def utils
    FileUtils::Verbose
  end

  # @param [Pathname|String] file
  # @param [Pathname] target
  # @param [Etc::Passwd] user
  def copy_auth(file, target, user = nil)
    utils.mkdir_p(target.dirname)
    utils.chmod(0o700, target.dirname)
    utils.cp(file, target)

    utils.chmod(0o600, target)
    utils.chown(user.uid, user.gid, target) if user
  end

  # @raise [Errno::EOPNOTSUPP]
  # @return [Boolean]
  def sh(*command)
    warn(Shellwords.join(command))

    system(*command).tap do |res|
      return res if res

      "#{Shellwords.join(command)} [#{$CHILD_STATUS.exitstatus}]".tap do |s|
        raise Errno::EOPNOTSUPP, s
      end
    end
  end
end

if __FILE__ == $PROGRAM_NAME
  DropbearSetup.new.call
end

# rubocop:enable Style/AsciiComments
